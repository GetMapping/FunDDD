### 애그리거트
- 애그리거트 = 엔티티 + 밸류

#### 애그리거트
- 상위 수준 개념을 이용해서 전체 모델을 정리하면 전반적인 관계를 이해하는데 도움이 된다.
  - 도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다.
  - 즉, 주요 도메인 요소 간의 관계를 파악하기 어렵다는 것은 코드를 변경하고 확장하는 것이 어려워진다는 것을 의미
- 모델을 이해하는 데 도움을 줄 뿐만 아니라 일관성을 관리하는 기준도 된다.
- 복잡도를 낮춰 도메인 기능을 확장하고 변경하는 데 필요한 노력(개발 시간)이 줄어든다.
- 도메인에 대한 경험이 생기고 도메인 규칙을 제대로 이해할수록 애그리거트의 실제 크기는 줄어든다.
- 두 개 이상의 엔티티로 구성되는 애그리거트는 드물다.

![image](https://github.com/prgrms-web-devcourse/Team_DOKEV_GOLDDDUCK_BE/assets/73349375/2e0cedba-7048-4208-b22b-dfcc2a97cafd)
![image](https://github.com/prgrms-web-devcourse/Team_DOKEV_GOLDDDUCK_BE/assets/73349375/1f3f6690-bda1-43dc-8ae2-83902d3b4cd6)

### 애그리거트 루트
- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요, 이 때 책임을 지는 것이 '애그리거트 루트'이다.
  (즉, 애그리거트의 대표 엔티티)

- 애그리거트 루트의 핵심 역할은 일관성이 깨지지 않도록 하는 것.
- 에그리거트 루트는 도메인 규칙을 구현한 기능을 제공한다.
- 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안됨 -> 논리적인 데이터 일관성이 깨짐.
- 그렇다고 응용 서비스에서 구현하게 되면, 동일한 로직을 중복으로 구현할 가능성이 높아져 유지보수에 도움이 되지 않음.

- 불필요한 중복을 피하고 에그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 다음 두가지를 습관적으로 적용해야함.
  - 단순히 필드를 변경하는 set 메서드를 public 범위로 만들지 않는다.
    - 이유) 공개 set 메소드는 도메인의 의미나 의도를 표현 못함, 도메인 로직을 도메인 영역이 아닌 응용 또는 표현 영역으로 분산시킨다.
  - 밸류 타입은 불변으로 구현한다.
    - 이유) 값을 변경 못하면 애그리거트 루트에서 밸류 객체를 구해도 애그리거트 외부에서 밸류 객체의 상태를 변경 못함.

- 트랜잭션의 범위는 작을 수록 좋다.
- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다.
- 부득이하게 한 트랜잭션으로 두 개 이상의 애그리거트를 수정해야한다면, 응용 서비스에서 두 애그리거트를 수정하도록 구현해야한다.
  - 다음 경우 하나의 트랜잭션에서 두 개 이상의 애그리거트를 변경하는 것을 고려할 수 있다.
    1. 팀 표준
    2. 기술 제약
    3. UI 구현의 편리성

### 리포지터리와 애그리거트
- 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다.
- 애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야한다.

### ID를 이용한 애그리거트 참조
- 애그리거트에서 다른 애그리거트를 참조한다는 것은 다른 애그리거트 루트를 참조하는 것과 같다.
- 참조시 다른 애그리거트를 필드로 참조할 수 있지만 다음과 같은 문제점이 생긴다.
  - 편한 탐색 오용
    - 다른 애그리거트의 상태를 쉽게 변경 가능 -> 의존 결합도를 높임, 애그리거트 변경이 어려워짐.
  - 성능에 대한 고민
    - 지연로딩이 유리한 경우가 많기 때문
  - 확장 어려움
    - 하위 도메인별로 시스템을 분리하면서, 도메인마다 서로 다른 DBMS를 사용할 경우 확장이 어려움.

- ID를 참조하게 되면 복잡도를 낮춰주고 응집도를 높여준다.
- 구현 복잡도도 낮아진다.
- ID를 통해서 조회가 필요하기 때문에 지연로딩을 하는것과 같아진다.
- 애그리거트별로 다른 구현 기술을 사용하는 것도 가능해진다.
- 하지만 ID를 통해서 하나씩 조회하게 되면, N+1문제가 발생하게 된다.
- 이를 해결할 방법은 조회 전용 쿼리를 사용하면된다.
- 만약 애그리거트마다 다른 저장소를 사용하면, 조회 성능을 높이기 위해서는 캐시나 조회 전용 저장소를 따로 구성한다.
  - 이는 코드는 좀 복잡해지지만 시스템의 처리량을 높일 수 잇다는 장점이 있다.

### 애그리거트 간 집합 연관
- 애그리거트간 컬렉션을 이용한 연관으로, '1-N', 'M-N연관'이 있다.
#### 1-N 연관
  - 하나의 Category에 여러개의 Product를 가질 때 예시
  ```java
  public class Category {
      private Set<Product> products;  // 1-N 연관 (Category-Product)
  
      public List<Product> getProducts(int page, int size) {
          List<Product> sortedProducts = sortById(products);
        return sortedProducts.subList((page - 1) * size, page * size);
      }
  }
  ```
  - 상위 코드의 문제점
    - 실행 속도가 급격히 느려져 성능에 심각한 문제를 야기할 수 있다.
    - 따라서 실제 구현에 이렇게 반영하지 않는다.
  
  ```java
  public class Product {
      private CategoryId categoryId;
  }
  ```
  - CategoryId로 연관 관계를 가졌을 때, 응용 서비스에서 ProductRepository를 이용해서 categoryId가 지정한 Product목록을 구하면 된다.

#### M-N 연관
  - 개념적으로 양쪽 애그리거트에 컬렉션에 연관을 만든다.
  - 요구사항을 고려해봤을 때 개념적으로는 M-N 연관이 존재하지만 실제 구현에서는 단방향 M-N 연관만 적용하면 된다.
  ```java
  public class Product {
      private Set<CategoryId> categoryIds;
  }
  ```

### 애그리거트를 팩토리로 사용하기
125P 예시 (상점 계정이 차단 상태가 아닌 경우 상품을 생성할 수 있도록 하는 예시)

- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트에 팩토리 메서드를 구현하는 것을 고려해보자.
  - 장점
    - 응용 서비스에서 더 이상 Store의 상태를 확인하지 않는다는 것
    - 도메인의 응집도도 높아졌다.
- Store 애그리거트가 Product 애그리거트를 생성할 때 많은 정보를 알아야 한다면 Store 애그리거트에서 Product 애그리거트를 직접 생성하지 않고, 다른 팩토리에 위임하는 방법도 잇다.