### 5.1 시작에 앞서
- CQRS : 명령(command) 모델과 조회(Query)모델을 분리하는 패턴
- 도메인 모델(엔티티, 애그리거트, 리포지터리 등)은 명령 모델로 주로 사용된다.
- 이 장에서는 조회 모델을 구현할 때 구현 방법을 살펴볼 것이다.

### 5.2 검색을 위한 스펙
- Specification : 검색 조건을 다양하게 조합해야할 때 사용
- 애그리거트가 특정 조건을 충족하는 지 검사할 때 사용하는 인터페이스
- 리포지터리나 DAO는 검색 대상을 걸러내는 용도로 스펙을 사용한다.
- isSatisfiedBy 를 통해 객체가 조건을 충족하는지 boolean값으로 받을 수 있다.
- 스펙은 메모리에 보관된다. 따라서 176~ 177P 예시처럼 사용하게 되면 조회 성능에 문제가 생길 수 있어 실제 스펙은 기술에 맞춰 구현하게 된다.

### 5.3 스프링 데이터 JPA를 이용한 스펙 구현
- 스펙 인터페이스에서 지네릭 타입 파라미터는 JPA의 엔티티 타입을 의미한다.
- JPA 크리테리아 API에서 조건을 표현할 때 Predicate를 생성한다.
- 스펙 인터페이스를 구현한 클래스 예시 -> 179P 리스트 5.2 참고

### 5.4 리포지터리/DAO에서 스펙 사용하기
- 스펙을 충족하는 엔티티를 검색하고 싶다면 findAll()메서드를 사용하면 된다.
- 182P 예시 참고

### 5.5 스펙 조합
- 스펙을 조합할 수 있는 메서드로 and, or이 있다.
- 꼭 개별 스펙마다 변수를 선언하지 않고도 쓸 수 있다.(184P 예시)
- 스펙 인터페이스는 not 메서드도 제공한다.
- null 검사가 필요할 경우 where을 사용하면 유용하다.
  - null이 아닌 경우 스펙 객체를 그대로 리턴, null인 경우 아무 조건도 생성하지 않는 스펙 객체를 리턴

### 5.6 정렬 지정하기
- 스프링 데이터 JPA는 OrderBy와 Sort를 이용하여 정렬을 지정할 수 있다.
- 186P 예시 참고

### 5.7 페이징 처리하기
- Pageable을 사용하면 자동으로 페이징을 처리해준다.
- 리턴타입이 Page일 경우 전체 데이터 갯수도 구해준다.

### 5.8 스펙 조합을 위한 스펙 빌더 클래스
- 여러 스펙을 조합하는 코드의 경우 호출 체인으로 연속된 변수 할당을 줄여 코드 가독성을 높이고 구조를 단순하게 만들 수 있다.
- 190P 예시 참고
- 스펙 빌더 코드는 and(), ifHasText(), ifTrue()와 같은 메서드가 있다. 이외에 필요한 메소드는 추가해서 사용하면 된다.

### 5.9 동적 인스턴스 생성
- JPA는 쿼리 결과에서 임의의 객체를 동적으로 생성할 수 있는 기능을 제공한다.
- 장점: JPQL을 그대로 사용하기에 지연/즉시 로딩과 같은 고민이 필요없이 데이터를 조회할 수 있다.

### 5.10 하이버네이트 @Subselect 사용
- @Subselect는 쿼리 결과를 @Entity로 매핑할 수 있는 유용한 기능이다.
- @Subselect로 조회한 @Entity 역시 수정할 수 없다. -> 수정시 하이버네이트에서 에러 발생한다.
- 따라서 @Immutable, @Syncronize을 사용
  - @Immutable의 경우 매핑 필드/프로퍼티가 변경되더라도 DB에 반영하지 않고 무시한다.
  - @Syncronize의 경우 엔티티와 관련된 테이블 목록을 명시하면 하이버네이트는 엔티티를 로딩하기 전에 지정한 테이블과 관련된 변경이 발생하면서 플러시를 먼저 한다.
  - 만일 서브쿼리를 사용하고 싶지 않다면 네이티브 SQL 쿼리를 사용하거나 마이바티스와 같은 별도 매퍼를 사용해서 조회기능을 구현해야 한다.