## 4.1 jpa를 이용한 리포지터리 구현

- jpa : rdbms 사용시 java orm 표준
- 리포지터리 인터페이스는 애그리거트와 함꼐 도메인 영역에 속함/ 구현한 클래스는 인프라 스트럭처 영역(domin.impl과 같은 패키지에 위치시키기도함,but 의존성을 낮추기 위해 분리 권장)
    
- 리포지터리 기본기능 : id로 애그리거트 조회& 애그리거트 저장
    - jpa는 트랜잭션 범위에서 변경한 데이터를 자동으로 DB에 반영
    - ID외의 조건으로 애그리거트 조회시 Criteria or JPQL 사용
    

## 4.2 스프링데이터JPA를 이용한 리포지터리 구현

- 스프링 데이터 jpa는 지정한 규칙에 맞게 리포지터리 인터페이스를 정의하면 구현객체를 알아서 만들어 bean으로 등록함
    - 인터페이스 생성 & 상속하여 구현 → 인터페이스 상속하여 인터페이스 작성

## 4.3 매핑 구현 (JPA와)

- **엔티티와 밸류 매핑**
    - 애그리거트 루트 : @Entity
    - 밸류 : @Embeddable / 밸류 타입 프로퍼티 : @Embedded
        - 컬럼 이름을 변경하기 위해서 는 @AttributeOverrides 사용
- **기본 생성자**
    - 불변 타입이면 생성시에 모든 값을 전달받고 set 메소드 제공 X
    - but JPA 사용시 클래스 매핑을 위해 기본 생성자 필요(protected로 선언)
- **jpa가 entity 필드에 접근하는 방식 :** 필드/메서드
    - set대신 메서드 의도가 드러나도록 기능 제공
    - 이를 위해 jpa 매핑 처리를 프로퍼티가 아닌 필드방식으로 선택
        - @Access(AccessType.FIELD) : 필드에 직접 접근 ,@ID가 필드에 위치 시
        - @Access(AccessType.PROPERTY) : 접근자(get) 사용, @ID가 메서드에 위치 시
        - 추가 정보 : 프록시와 식별자
            
            https://goldfishhead.tistory.com/92
            
            엔티티 접근 방식을 필드(@Access(AccessType.FIELD))로 설정하면 getId() 메소드가 id만 조회하는 메소드인지 다른 필드까지 활용해서 어떤 일을 하는 메소드인지 알지 못하므로 프록시 객체를 초기화한다.
            
            참고로 연관관계를 설정할 때는 엔티티 접근 방식을 필드로 설정해도 프록시를 초기화하지 않는다.
            
- 두개 이상의 프로퍼티를 가진 **밸류 타입을 한개 컬럼에 매핑** 시 AttributeConverter를 이용하여 밸류 매핑처리
    - AttributeConverter를 상속하여 구현하고 @Convert 어노테이션
- **밸류컬렉션 ↔ 별도테이블** **매핑**
    - @**ElementCollection** 과
    - @**CollectionTable**(밸류를 저장할 테이블 지정) 사용
        - @joincolumn외부키가 두개 이상인 경우 배열 이용
    - @OrderColumn을 통해 리스트의 인덱스 값 저장(순서 저장 가능)
    - why? 엔티티로 안만들고 밸류 타입으로 만들어서 복잡하게 매핑?
- **밸류컬렉션 ↔ 한개 컬럼 매핑** 시 **AttributeConverter**이용하여 한개의 String등으로 만듬(밸류 컬렉션을 위한 밸류 타입 추가 작성 필요)
- 식별자라는 의미를 부각시키기 위해 식별자를 밸류 타입으로 만들어 **밸류를 이용한 ID 매핑**
    - @Id 대신 @EmbeddedId 사용, JPA 에서 식별자 타입은 Serializable 상속해야 함
    - 식별자에 기능 추가 가능
- **별도 테이블에 저장하는 밸류 매핑**
    - 별도 테이블에 데이터를 저장한다고 다 엔티티는 아님
    - 엔티티가 확실하다면 다른 애그리거트가 아닌지 확인(자신만의 독자적인 라이프 사이클 가짐, 객체간 변경이 영향)
    - 고유 식별자를 가져야지 엔티티, 테이블의 식별자를 애그리거트 식별자와 동일시 X
    - @**SencondaryTable** 을 이용하여 밸류를 저장한 테이블 지정(조회시 조인하여 조회)
    - 항상 밸류테이블을 조회하는 문제 발생 → 엔티티로 매핑하여 지연로딩으로 설정 →조회 전용 기능 구현(5,11장에서 다룸)
- **밸류 컬렌셕을 엔티티로 매핑**
    - 개념적으로 밸류인데 기술적 한계나 팀표준으로 엔티티를 사용하는 경우
    - JPA는 @Embeddable의 상속을 지원하지 않아서 @Entity를 사용해야함
        - 상속 설정 : @Inheritance (single_table,join,table_pewr_class) https://ict-nroo.tistory.com/128
        - @DiscriminatorColumn : 타입 구분용으로 사용할 컬럼 지정
        - 엔티티로 구현했지만 밸류 타입임으로 상태를 변경하는 기능을 추가하지 않는다
        - 상속받은 클래스는 @Discriminator를 사용하여 매핑 설정
        - 밸류타입이기에 독자적인 라이프 사이클을 가지지 않아 OneTOmany에 cascase를 설정
        - 교체시 clear하고 전체 add → 하이버네이트는 @embeddable 타입의 컬력션의 clear의 경우 객체를 로딩하지않고 delete한번으로 처리 (상속을 포기하고 타입에 따라if 문 처리)
        - @embeddable 과 상속은 코드 유지보수와 선능 두가지 측면을 고려하여 구현 방식 선택
    - **Id참조와 조인 테이블을 이용한 단방향 m:n 매핑**
        - 애그리거트간 집합연관은 성능상의 이유로 피해야하지만 필요시 ID 참조를 이용한 단방향 집합 연관 적용
        - @ElementCollection 사용 시 ****조인테이블의 데이터도 삭제됨. id를 참조 방식을 사용함으로서 영속성전파나 로딩전략에서 자유로움(객체 대신 조인데이블데이터가 삭제됨)

## 4.4 애그리거트 로딩 전략

- 애그리거트에 속한 객체가 모두 모여야 완전한 하나가 됨, 개념적으로 하나
- 즉시 로딩으로 설정시 모든 객체를 함꼐 로딩할 수 있지만 컬렉션을 조회하는 등의 경우 카타시안 조인을 사용하여 결과에 중복 발생(하이버네이트가 중복데이터를 제거하여 메모리에는 알맞게 변환)
- 애그리거트는 상태를 변경할 때 애그리거트가 완전한 상태여야하고, 표현 영역에서 애그리거트의 상태정보를 보여줄때 필요하기 때문에 완전해야함.
    - 두번째는 별도의 조회전용기능과 모델 구현
    - 상태 변경 기능에는 지연 로딩을 통해 필요 시점에 로딩
    - 주로 조회기능의 빈도가 더 높기 때문에 지연로딩으로인한 속도 저하는 감수

## 4.5 애그리거트의 영속성 전파

- 애그리거트가 완전한 상태라는것은 조회,저장,삭제 시 모두 하나로(함께) 처리되야함
    - @Embeddable은 라이프사이클을 함께함, @entity타입은 cascade 속성 사용 필요
    - Q? 이미지를 삭제하는 경우에는 저장된 이미지는 어떻게 지우는지

## 4.6 식별자 생성 기능

- 식별자는 사용자가 직접생성/도메인로직으로 생성/DB를통한일련번호로 생성
- 식별자 생성 규칙이 있다면 엔티티 생성시 별도 서비스로 식별자 생성 기능 분리(도메인영역에)
- or 리포지터리에 식별자 생성 메서드를 추가하고 구현클래스에서 구현
- DB 자동증가 칼럼 사용시 @GeneratedValue사용 (도메인 객체 db에 저장시 생성)

## 4.7 도메인 구현과 DIP

- DIP의 의도는 저수준 구현이 변경되더라도 고수준이 영향을 받지 않도록 하기위함
- 하지만 리포지터리와 도메인 모델의 구현기술은 거의 바뀌지 않기 때문에 타협 (jpa→mybatis / rdbms→nosql)
    - DIP에 따르면 @Entity와 @Table 등은 구현기술에 속하여 도메인 모델에서 영속성 구현 기술인JPA에 의존하면 안되지만 의존중.(인프라에 의존)
    - 리포지터리도 도메인 패키지에 위치하지만 JPA에 의존중
    - 의존을 제거하기 위해서는 인터페이스를 구현한 클래스를 인프라에 위치시키고 어노테이션을 지우고 인프라에 jpa연동을 위한 클래스 추가
- 도메인 모델을 단위 테스트하는데 문제는 없음, DIP를 완벽하게 지키면 좋겠지만 개발 편의성과 실용성을 가져가면서 구조적인 유연함을 유지
