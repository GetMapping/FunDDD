# 8장 애그리거트 트랜잭션 관리

## 8.1 애그리거트와 트랜잭션

- 트랜잭션마다 리포지터리는 새로운 애그리거트를 생성하므로 같은 애그리거트를 나타내는 다른 객체를 구한다. =일관성이 깨진다
- 상태를 변경하는동아 고객이 수정하지 못하게 한다 =선점 = 비관적 = pessimistic
- 다시 조회 한 뒤 수정하도록 한다 = 비선점 = 낙관적 =optimistic

## 8.2 선점 잠금

- 먼저 애그리거트를 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 애그리거트를 수정하지 못하게 막는다
- 잠금을 해제할때 까지 대기하여 충돌을 해결. 고객은 변경할 수 없다는 안내문구를 보게 된다
- 보통 DBMS가 제공하는 행단위 잠금을 사용해서 구현
    - DbMS는 for update와 같은 쿼리를 사용하여 특정 레코드에 한 커넥션만 접근 할 수 있게함
    - JPA같은 경우는 대항 엔티티와 매핑된 테이블을 이용해서 선점 잠금 방식 적용 (LockModeType.pessimistic_write, 하이버네이트는 find옵션, 스프링데이터jpa는 @Lock)
- 교착 상태가 되지 않도록 주의해야한다 (dead lock)
    - 스레드 1: A → B 순으로 선점잠금 구함
    - 스레드 2 : B→A 순으로 선점잠금 구함
    - 이경우 스레드 1은 영원히 B애그리거트에 대한 선점잠금을 구할 수 없어 교착 상태에 빠진다
    - 사용자가 많을 때 발생할 가능성이 좊고 , 교착상태에 빠지는 스레드가 빠르게 증가한다
    - 예방을 위해 최대대기 시간을 지정해야한다(@QueryHint 사용)
    

## 8.3 비선점 잠금

- 선점 잠금으로도 해결할 수 없는 트랜잭션 충돌문제가 있다
- 배송 상태 변경 전에 배송지를 한번 더 확인해야함 ( 실제 반영하는 시점에 변경 가능 여부 확인)
- 애그리거트에 버전으로 사용할 숫자타입 프로퍼티를 추가해야 한다.
    - JPA 에서는 @version을 통해 해당 기능을 이용할 수 있다 (응용서비스는 버전에 대해 알 필요없고 종료시점에 알아서 비교및 업데이트 쿼리 실행, OptimisticLockingFailureException 발생)
- 이를 확장하여 폼에 버전을 추가하여 동일한 경우에만 쿼리를 실행하는 방법도 있다.(서비스에서 확인하고 표현계층에 이를 알린다, 트랜잭션 충돌이 발생한 시점이 위와 구별됨(미리or거의동시에))
- 애그리거트 루트 외에 다른 엔티티가 존재하지만 다른 엔티티만 변경되는경우 JPA는 루트 엔티티의 버전을 증가시키지 않는다. 이 경우 논리적 애그리거트관점에서  문제가 되어 올바르게 동작하기 때문에 강제 버전 증가 모드 옵션을 사용한다 (LockModeType.optimistic_force_increment, 하이버네이트는 find옵션, 스프링데이터jpa는 @Lock)

## 8.4 오프라인 선점 잠금

- 단일 트랜잭션에서 동시변경을 막는 선점 잠금 방식과 달리 **여러 트랜잭션에 걸쳐** 동시 변경을 막는 방식이 오프라인 선점 방식이다. 첫번째 트랜잭션을 시작 할 때 오프라인 잠금을 선점하고 마지막 트랜잭션에서 잠금을 해제한다   
- 이미 잠금을 선점한 상태에서 다른 사용자가 폼을 요청하면 선점할수 없어 에러 화면이 보인다. ( 영원히 선점하는 경우를 방지하기위해 유효 시간 필요)
- Q 뭐가다르지 선점잠금과? -> 여러 트랜잭션?
- 선점잠금 시도/잠금확인/ 잠금해제/잠금유효시간 연장 이 구현을 위해 필요한 인터페이스 메서드
    - Lockmanager 인터페이스에 구현
    - lockId를 통해 잠금을 접근을 제어한다(저장필요)
    - checkLock를 통해 잠금유효시간을 확인하고 선점한 사람인지 확인해야한다.
- DB 를 통해 Lockmanager 구현
    - locks  테이블을 생성하여 id, 유효기간, 등을 저장
    - 잠금이 존재하는지 검사→잠금을 시도하여 테이블에 저장
    - 유효기간이 지나면 데이터를 삭제하고 빈 옵셔널 리턴
